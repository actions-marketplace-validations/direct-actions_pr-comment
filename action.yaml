name: Pull Request Comment Direct

branding:
  icon: message-square
  color: blue

description: >
  Easy comment interaction with persistent key based comment tracking across
  multiple runs. Upsert, post, delete comments.

inputs:
  author:
    default: ''
    description: (Optional) specify author name to match existing comment(s).
    required: false
    type: string
  classifier:
    default: resolved
    description: Override default classifier on `minimize` operation.
    required: false
    type: string
  comment:
    default: ''
    description: Body of comment, used with `post` or `upsert` operation.
    required: false
    type: string
  key:
    default: ''
    description: (Optional) Unique & hidden key used to match comment(s) across operations.
    required: false
    type: string
  match:
    default: last
    description: Mode to operate on exiting comments, can be `first`, `last` or `all`.
    required: false
    type: string
  operation:
    default: upsert
    description: Operation to execute - can be one of `delete`, `get`, `list-keys`, `minimize`, `post`, `upsert` (default).
    required: false
    type: string
  pull-request:
    default: ${{ github.event.number }}
    description: Override pull request number (default is auto-determined based on pull_request event).
    required: false
    type: string
  quiet:
    default: false
    description: Do not output warnings when attempting operations on non-matching comments.
    required: false
    type: string
  regex:
    default: ''
    description: (Optional) Regular expression to test body of existing comment(s) for `delete`, `get`, or `upsert` operations.
    required: false
    type: string
  regex-flags:
    default: ''
    description: (Optional) Regex flags used along with regex argument; see jq regex documention for details.
    required: false
    type: string
  repository:
    default: ${{ github.repository }}
    description: Override repository name (default is repo the action is run in) - use `owner/repo` format.
    required: false
    type: string
  token:
    default: ${{ github.token }}
    description: Override default GitHub token.
    required: false
    type: string
outputs:
  keys:
    description: JSON list of keys found on a `list-keys` operation.
    value: ${{ steps.operation.outputs.keys }}
  json-output:
    description: JSON output of last API operation.
    value: ${{ steps.operation.outputs.json-output }}

runs:
  using: composite
  steps:
    - env:
        CLASSIFIER: ${{ inputs.classifier }}
        COMMENT: ${{ inputs.comment }}
        COMMENT_KEY: ${{ inputs.key }}
        GITHUB_TOKEN: ${{ inputs.token }}
        OPERATION: ${{ inputs.operation }}
        PULL_REQUEST: ${{ inputs.pull-request }}
        QUIET: ${{ inputs.quiet }}
        REPOSITORY: ${{ inputs.repository }}
      id: operation
      if: ${{ inputs.operation != 'post' }}
      run: |
        # ${{ inputs.operation }}
        if [ "$ACTIONS_RUNNER_DEBUG" == 'true' ] ; then
          set -x
        fi

        ALL_COMMENTS=$(mktemp)
        CLASSIFIER="$(tr '[a-z]' '[A-Z]' <<< "$CLASSIFIER")"
        COMMENT='<!--direct-actions/pr-comment:key:'"${COMMENT_KEY}-->"$'\n'"${COMMENT}"
        COMMENTS=$(mktemp)
        ERROR=$(mktemp)

        gh_api() {
          local operation="$1"
          local method="$2"
          local url="$3"
          local comment="$4"
          local output=$(mktemp)

          if ! gh api \
              --method "$method" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$url" \
              -f body="${comment}" \
              >"$output" 2>"$ERROR" ; then
            echo "::error title=direct-actions/pr-comment - API error::" \
              "::Operation (${operation}) method ${method} url ${url} failed -" \
              "\"$(cat "$ERROR")\"."
            exit 1
          fi
          if [ "$QUIET" != 'true' ] ; then
            echo "::group::operation=${operation} method=${method} url=${url}"
            jq -C . "$output"
            echo "::endgroup::"
          fi
          jq -r '"json-output<<_EOF_\n\(@json)\n_EOF_\n"' "$output" >> "$GITHUB_OUTPUT"
        }

        if [ -z "$PULL_REQUEST" ] ; then
          echo "::error title=direct-actions/pr-comment - Cannot determine" \
            "pull request::Cannot determine pull request number in this" \
            "sitation, pass explicitly via pull-request input."
          exit 1
        elif [ -z "$REPOSITORY" ] ; then
          echo "::error title=direct-actions/pr-comment - Cannot determine" \
            "repository::Cannot determine repository in this situation, pass" \
            "explicitly via repository input."
          exit 1
        elif ! gh api \
            --method GET \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${REPOSITORY}/issues/${PULL_REQUEST}/comments" \
            > "$ALL_COMMENTS" 2> "$ERROR" ; then
          echo "::error title=direct-actions/pr-comment - Could not retrieve" \
            "comments::Error retrieving comments from repository (${REPOSITORY})" \
            "PR number (${PULL_REQUEST}) - \"$(cat "$ERROR")\"."
          exit 1
        fi

        if [ "$ACTIONS_RUNNER_DEBUG" == 'true' ] ; then echo ::group::all_comments.json
          jq -C . "$ALL_COMMENTS"
          echo ::endgroup::
        fi

        jq \
          --arg author '${{ inputs.author }}' \
          --arg key '${{ inputs.key }}' \
          --arg match '${{ inputs.match }}' \
          --arg regex '${{ inputs.regex }}' \
          --arg regex_flags '${{ inputs.regex-flags }}' \
          -r '
            map(
              if $ARGS.named.author? != "" then
                select(.author.login == $ARGS.named.author)
              else
                .
              end |
              if $ARGS.named.key? != "" then
                select(
                  .body |
                  startswith("<!--direct-actions/pr-comment:key:\($ARGS.named.key)-->")
                )
              else
                .
              end |
              if $ARGS.named.regex? != "" then
                select(.body | test($ARGS.named.regex ; $ARGS.named.regex_flags))
              else
              .
              end
            ) |
            if length == 0 then
              []
            elif $ARGS.named.match? == "all" then
              .
            elif $ARGS.named.match? == "first" then
              [first]
            elif $ARGS.named.match? == "last" then
              [last]
            else
              error("Unknown value for argument \"match\": \($ARGS.named.match)")
            end
          ' "$ALL_COMMENTS" > \
          "$COMMENTS"
        NUM_COMMENTS=$(jq -r length "$COMMENTS")

        if [ "$ACTIONS_RUNNER_DEBUG" == 'true' ] ; then
          echo "::group::Matching comments (${NUM_COMMENTS})::"
          jq -C . "$COMMENTS"
          echo '::endgroup::'
        fi

        if [ "$OPERATION" == 'post' ] || [[ "$OPERATION" == 'upsert' && "$NUM_COMMENTS" -eq 0 ]]; then
          gh_api "$OPERATION" POST "/repos/${REPOSITORY}/issues/${PULL_REQUEST}/comments" "$COMMENT"
        elif [ "$OPERATION" == 'list-keys' ] ; then
          jq '
            map(
              .body |
              scan("^<!--direct-actions/pr-comment:key:([^>]*)-->")
            ) |
            flatten |
            unique |
            "keys=\(@json)"
          ' \
          "$ALL_COMMENTS" | \
          tee -a "$GITHUB_OUTPUT"
        elif [[ "$OPERATION" =~ ^(delete|get|minimize|upsert)$ ]] ; then
          if [ "$NUM_COMMENTS" -eq 0 ] && [ "$QUIET" != 'true' ] ; then
            echo "::warning title=direct-actions/pr-comment - Cannot perform" \
              "operation::Attempting operation ${OPERATION} but cannot find" \
              "matching comment(s)."
          else
            for (( x=0 ; x < NUM_COMMENTS ; x++ )) ; do 
              ID=$(jq --arg index "$x" -r '.[$index | tonumber].id' "$COMMENTS")
              URL="/repos/${REPOSITORY}/issues/comments/${ID}"
              case "$OPERATION" in
                delete)
                  gh_api "$OPERATION" DELETE "$URL" "$COMMENT"
                  ;;
                get)
                  gh_api "$OPERATION" GET "$URL" "$COMMENT"
                  ;;
                minimize)
                  echo "::group::operation=${OPERATION} graphql minimizeComment node_id=${NODE_ID} classifier=${CLASSIFIER}"
                  NODE_ID=$(jq --arg index "$x" -r '.[$index | tonumber].node_id' "$COMMENTS")
                  gh api graphql \
                    -f query="
                      mutation {
                        minimizeComment(input: { subjectId: \"${NODE_ID}\", classifier: ${CLASSIFIER} }) {
                          clientMutationId
                        }
                      }"
                  echo '::endgroup::'
                  ;;
                upsert)
                  gh_api "$OPERATION" PATCH "$URL" "$COMMENT"
                  ;;
              esac
            done
          fi
        else
          echo "::warning title=direct-actions/pr-comment - Invalid" \
            "operation::Invalid operation (${OPERATION}) specified."
          exit 1
        fi
      shell: bash
